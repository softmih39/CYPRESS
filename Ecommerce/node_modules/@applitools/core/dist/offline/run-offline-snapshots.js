"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runOfflineSnapshots = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const core_1 = require("../core");
const get_ufg_client_1 = require("../ufg/get-ufg-client");
const logger_1 = require("@applitools/logger");
const to_base_check_settings_1 = require("../automation/utils/to-base-check-settings");
const chalk_1 = __importDefault(require("chalk"));
const utils = __importStar(require("@applitools/utils"));
const merge_configs_1 = require("./merge-configs");
const format_results_1 = require("../utils/format-results");
async function runOfflineSnapshots(options) {
    var _a;
    if (!options.offlineLocationPath)
        throw new Error('offlineLocationPath is required');
    const offlineLocationPath = path_1.default.resolve(options.offlineLocationPath);
    const startTime = Date.now();
    const logger = (_a = options.logger) !== null && _a !== void 0 ? _a : (0, logger_1.makeLogger)({ format: { label: 'offline-exec' } });
    const eyesServerSettings = { ...options.config.open, ...options };
    const core = (0, core_1.makeCore)();
    const account = await core.getAccountInfo({ settings: eyesServerSettings });
    const ufgClient = await (0, get_ufg_client_1.makeGetUFGClient)({ logger })({
        settings: { ...account.eyesServer, ...account.ufgServer },
    });
    const testFolders = (await fs_1.default.promises.readdir(offlineLocationPath))
        .filter(filename => filename.startsWith('test-'))
        .sort();
    if (testFolders.length === 1) {
        logger.console.log(`Running single test from folder ${offlineLocationPath}`);
    }
    else if (testFolders.length === 0) {
        logger.console.log('No test artifacts were found at', offlineLocationPath);
    }
    else {
        logger.console.log(`Running ${testFolders.length} tests from folder ${offlineLocationPath}`);
    }
    if (testFolders.length === 0) {
        throw new Error(`Unable to find offline executions in ${offlineLocationPath}`);
    }
    const allTestResults = await runTests(testFolders);
    const { isSuccess, outputStr } = processResults({
        testResults: allTestResults,
        totalTime: Date.now() - startTime,
        jsonFilePath: options.jsonFilePath,
    });
    if (!isSuccess && options.failOnDiff) {
        throw new Error(outputStr);
    }
    else {
        logger.console.log(outputStr);
    }
    return allTestResults;
    async function runTests(testFolders) {
        logger.log('running tests', testFolders);
        const results = await Promise.all(testFolders.map(async (testFolder) => {
            const testLogger = logger.extend({ tags: [testFolder] });
            const testPath = path_1.default.join(offlineLocationPath, testFolder);
            const fileOpenSettings = await fs_1.default.promises
                .readFile(path_1.default.join(testPath, 'settings.json'), 'utf-8')
                .then(JSON.parse);
            const openSettings = (0, merge_configs_1.mergeConfigs)(fileOpenSettings, options.config.open);
            logger.console.log(`Running test: ${openSettings.testName} (${formatEnvironment(openSettings.environment)})`);
            return runTest(testPath, openSettings, testLogger);
        }));
        const batchIds = [...new Set(results.map(t => t.batchId))];
        const allTestResults = results.map(t => t.results);
        logger.log('done running all tests', allTestResults);
        const keepBatchOpen = utils.general.getEnvValue('DONT_CLOSE_BATCHES', 'boolean') || options.config.open.keepBatchOpen;
        if (!keepBatchOpen) {
            await core.closeBatch({ settings: batchIds.map(batchId => ({ batchId, ...account.eyesServer })) });
            logger.log('done closing batches');
        }
        return allTestResults;
    }
    async function runTest(testPath, openSettings, logger) {
        const environment = await ufgClient.getActualEnvironment({
            settings: { environment: openSettings.environment.requested },
        });
        const eyes = await core.base.openEyes({
            settings: {
                ...openSettings,
                environment: {
                    ...openSettings.environment,
                    ...environment,
                },
                ...account.eyesServer,
            },
            logger,
        });
        const checkFolders = (await fs_1.default.promises.readdir(testPath)).filter(folderpath => folderpath.startsWith('check-'));
        logger.log('running checks for test', testPath, ':', checkFolders);
        const targets = await Promise.all(checkFolders.map(async (checkFolder) => {
            const snapshot = await fs_1.default.promises
                .readFile(path_1.default.resolve(testPath, checkFolder, 'snapshot.json'), 'utf-8')
                .then(JSON.parse);
            snapshot.settings.environment.environmentId = utils.general.guid();
            return snapshot;
        }));
        await uploadResources(targets, logger);
        // logger.log('resource hashes for test', testFolder, ':', resourceHashes)
        logger.log('uploaded resources for test', testPath);
        await Promise.all(targets.map((target, index) => runCheck(eyes, target, index, logger)));
        const fileCloseSettings = await fs_1.default.promises.readFile(path_1.default.resolve(testPath, 'close.json'), 'utf-8').then(JSON.parse);
        const closeSettings = (0, merge_configs_1.mergeConfigs)(fileCloseSettings, options.config.close);
        await eyes.close({ settings: closeSettings });
        logger.log('done running test', logger);
        return { batchId: openSettings.batch.id, results: (await eyes.getResults({ logger }))[0] };
    }
    async function uploadResources(targets, logger) {
        const uploadLogger = logger.extend({ tags: ['upload-resources'] });
        const promises = targets.map(async ({ target }) => {
            let resourcePromises = Object.values(target.resources)
                .filter(isHashedResource)
                .map(async (resource) => {
                const contentfuleResource = {
                    id: '',
                    url: '',
                    value: await fs_1.default.promises.readFile(path_1.default.join(offlineLocationPath, 'resources', resource.hash)),
                    contentType: resource.contentType,
                    hash: resource,
                };
                return ufgClient.uploadResource({ resource: contentfuleResource, logger: uploadLogger });
            });
            resourcePromises = resourcePromises.concat(ufgClient.uploadResource({
                resource: {
                    id: '',
                    url: '',
                    value: await fs_1.default.promises.readFile(path_1.default.join(offlineLocationPath, 'resources', target.snapshot.hash)),
                    contentType: target.snapshot.contentType,
                    hash: target.snapshot,
                },
                logger: uploadLogger,
            }));
            return Promise.all(resourcePromises);
        });
        await Promise.all(promises);
        function isHashedResource(resource) {
            return 'hash' in resource;
        }
    }
    async function runCheck(eyes, target, index, logger) {
        var _a;
        const checkLogger = logger.extend({ tags: [`check-${index}`] });
        const { elementReferences: selectors, getBaseCheckSettings } = (0, to_base_check_settings_1.toBaseCheckSettings)({
            settings: target.settings,
        });
        const { renderId, selectorRegions, ...baseTarget } = await ufgClient.render({
            target: target.target,
            settings: {
                ...target.settings,
                region: (_a = selectors.target) !== null && _a !== void 0 ? _a : target.settings.region,
                scrollRootElement: selectors.scrolling,
                selectorsToCalculate: selectors.calculate,
                includeFullPageSize: Boolean(target.settings.pageId),
                environment: target.settings.environment,
                uploadUrl: account.uploadUrl,
                stitchingServiceUrl: account.stitchingServiceUrl,
            },
            logger: checkLogger,
        });
        const baseSettings = getBaseCheckSettings({
            calculatedRegions: selectors.calculate.map((_, index) => {
                var _a;
                return ({
                    regions: (_a = selectorRegions === null || selectorRegions === void 0 ? void 0 : selectorRegions[index]) !== null && _a !== void 0 ? _a : [],
                });
            }),
        });
        baseSettings.renderId = renderId;
        baseSettings.stepIndex = index;
        baseTarget.source = target.target.source; // TODO verify
        // baseTarget.name = snapshot.title // TODO figure out
        const mergedCheckSettings = (0, merge_configs_1.mergeConfigs)(baseSettings, options.config.check);
        await eyes.check({
            target: { ...baseTarget, isTransformed: true },
            settings: mergedCheckSettings,
            logger: checkLogger,
        });
    }
}
exports.runOfflineSnapshots = runOfflineSnapshots;
function uniq(arr) {
    return [...new Set(arr)];
}
function processResults({ testResults, totalTime, saveNewTests = true, failOnDiff = true, jsonFilePath, }) {
    let outputStr = '\n';
    const pluralize = utils.general.pluralize;
    const testResultsWithErrors = testResults.filter(r => r && r.reason);
    const unresolved = testResults.filter(r => r.isDifferent && !r.isAborted);
    const passedOrNew = testResults.filter(r => r.status === 'Passed' || (r.isNew && !r.isAborted));
    const aborted = testResults.filter(r => r.isAborted);
    const newTests = testResults.filter(r => r.isNew && !r.isAborted);
    const failedTests = testResults.filter(r => !r.reason && !r.isNew && !r.isAborted && !r.isDifferent && r.status === 'Failed');
    const newTestsSize = newTests.length;
    const warnForUnsavedNewTests = !!(!saveNewTests && newTestsSize);
    const errMessagesToExclude = ['detected differences', 'Please approve the new baseline', 'is failed! See details at'];
    const errors = testResultsWithErrors
        .filter(r => !errMessagesToExclude.some(msg => { var _a, _b; return (_b = (_a = r.reason) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes(msg); }))
        .map(r => ({
        error: r.reason,
        title: r.name,
    }));
    const hasResults = unresolved.length || passedOrNew.length || aborted.length;
    const seeDetailsStr = hasResults && `See details at ${(passedOrNew[0] || unresolved[0] || aborted[0]).appUrls.batch}`;
    if (hasResults) {
        outputStr += `${seeDetailsStr}\n\n`;
    }
    outputStr += '[EYES: TEST RESULTS]:\n\n';
    if (passedOrNew.length > 0) {
        outputStr += testResultsOutput(passedOrNew, warnForUnsavedNewTests);
    }
    if (failedTests.length > 0) {
        outputStr += testResultsOutput(failedTests, warnForUnsavedNewTests);
    }
    if (unresolved.length > 0) {
        outputStr += testResultsOutput(unresolved, warnForUnsavedNewTests);
    }
    if (aborted.length > 0) {
        outputStr += testResultsOutput(aborted, warnForUnsavedNewTests);
    }
    if (errors.length) {
        const sortedErrors = errors.sort((a, b) => a.title.localeCompare(b.title));
        outputStr += uniq(sortedErrors.map(({ title, error }) => `${title} - ${chalk_1.default.red('Failed')}. ${error.message || error.toString()}`)).join('\n');
        outputStr += '\n';
    }
    if (!errors.length && !hasResults) {
        outputStr += 'Test is finished but no results returned.\n';
    }
    const unresolvedOrFailed = unresolved.concat(failedTests);
    if (errors.length && !unresolvedOrFailed.length) {
        outputStr += chalk_1.default.red(`\nA total of ${errors.length} test${pluralize(errors.length)} failed for unexpected error${pluralize(errors.length)}.`);
    }
    else if (unresolvedOrFailed.length && !errors.length) {
        outputStr += chalk_1.default.keyword(failedTests.length ? 'red' : 'orange')(`\nA total of ${unresolvedOrFailed.length} difference${pluralize(unresolvedOrFailed.length, [
            's were',
            ' was',
        ])} found.`);
    }
    else if (unresolvedOrFailed.length || errors.length) {
        outputStr += chalk_1.default.red(`\nA total of ${unresolvedOrFailed.length} difference${pluralize(unresolvedOrFailed.length, [
            's were',
            ' was',
        ])} found and ${errors.length} test${pluralize(errors.length)} failed for ${pluralize(errors.length, [
            '',
            'an ',
        ])}unexpected error${pluralize(errors.length)}.`);
    }
    else if (warnForUnsavedNewTests) {
        const countText = newTestsSize > 1 ? `are ${newTestsSize} new tests` : `is a new test: '${newTests[0].name}'`;
        outputStr += chalk_1.default.red(`\n'saveNewTests' was set to false and there ${countText}. Please approve ${pluralize(newTestsSize, [
            'their',
            'its',
        ])} baseline${pluralize(newTestsSize)} in Eyes dashboard.\n`);
    }
    else if (passedOrNew.length) {
        outputStr += chalk_1.default.green(`\nNo differences were found!`);
    }
    if (jsonFilePath) {
        outputStr += '\n\nWriting test results to ' + jsonFilePath + '\n';
        fs_1.default.writeFileSync(jsonFilePath, (0, format_results_1.toJsonOutput)(testResults));
    }
    if (hasResults) {
        outputStr += `\n${seeDetailsStr}\nTotal time: ${Math.round(totalTime / 1000)} seconds\n`;
    }
    // if (Number(testConcurrency) === 5) {
    //   outputStr += `\n${concurrencyMsg}\n`
    // }
    let isSuccess;
    if (errors.length) {
        isSuccess = false;
    }
    else if (failOnDiff) {
        isSuccess = !warnForUnsavedNewTests && passedOrNew.length && !unresolvedOrFailed.length;
    }
    else {
        isSuccess = true;
    }
    return {
        outputStr,
        isSuccess,
    };
}
function testResultsOutput(results, warnForUnsavedNewTests) {
    let outputStr = '';
    const sortedTestResults = results.sort((a, b) => a.name.localeCompare(b.name));
    sortedTestResults.forEach(result => {
        const testTitle = `${result.name} [${result.hostApp}] [${result.hostDisplaySize.width}x${result.hostDisplaySize.height}] - `;
        if (result.isAborted) {
            outputStr += `${testTitle}${chalk_1.default.keyword('red')(`Aborted`)}\n`;
        }
        else if (result.isNew) {
            const newResColor = warnForUnsavedNewTests ? 'orange' : 'blue';
            outputStr += `${testTitle}${chalk_1.default.keyword(newResColor)('New')}\n`;
        }
        else if (result.status === 'Passed') {
            outputStr += `${testTitle}${chalk_1.default.green('Passed')}\n`;
        }
        else if (result.status === 'Failed') {
            outputStr += `${testTitle}${chalk_1.default.keyword('red')('Failed')}\n`;
        }
        else {
            outputStr += `${testTitle}${chalk_1.default.keyword('orange')(`Unresolved`)}\n`;
        }
    });
    outputStr += '\n';
    return outputStr;
}
function formatEnvironment(environment) {
    const env = environment.requested;
    if (isChromeEmulation(env)) {
        return `${env.chromeEmulationInfo.deviceName}${env.chromeEmulationInfo.screenOrientation ? ` [${env.chromeEmulationInfo.screenOrientation}]` : ''}`;
    }
    else if (isIOSDevice(env)) {
        return `${env.iosDeviceInfo.deviceName}${env.iosDeviceInfo.screenOrientation ? ` [${env.iosDeviceInfo.screenOrientation}]` : ''}`;
    }
    else if (isAndroidDevice(env)) {
        return `${env.androidDeviceInfo.deviceName}${env.androidDeviceInfo.screenOrientation ? ` [${env.androidDeviceInfo.screenOrientation}]` : ''}`;
    }
    else {
        return `${env.name} [${env.width}x${env.height}]`;
    }
    function isChromeEmulation(env) {
        return env.chromeEmulationInfo;
    }
    function isIOSDevice(env) {
        return env.iosDeviceInfo;
    }
    function isAndroidDevice(env) {
        return env.androidDeviceInfo;
    }
}
